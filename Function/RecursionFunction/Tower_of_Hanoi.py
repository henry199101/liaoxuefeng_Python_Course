def move(n, a, b, c):
    if n == 1:
        print(a, '->', c)
        return
    move(n-1,a,c,b)
    move(1,a,b,c)
    move(n-1,b,a,c)
'''
汉诺塔游戏是什么可自行百度，n 表示盘子的数量（从上至下由小到大坐落在A柱子上），a,b,c 分别代表 A，B，C三个柱子，目的是将A的盘子全部移动到C柱子上，过程中必须保证一个原则：大盘子始终在下面，小盘子在上面；下面解释代码

if n == 1:        # 如果只有一个盘子，废话不多说，直接移动到C上面即可
    print(a, '->', c)
    return
如果盘子的数量大于1，玩过汉诺塔游戏(可自己去应用商店下载)的人可能会发现，不管盘子数量有多少，最终遵循的逻辑是：先把上面的n-1个盘子移动到B柱子上，然后把最底层的盘子移动到C柱子上，最后将B柱子上的n-1个盘子移动到 C 柱子上，这样就完成任务了；

用递归思维来考虑，最后一层栈肯定是 n == 1，也就是 print(a, '-->',c)

敲黑板！！！此处 a,b,c 是参数，A,B,C是参数值，参数值是可以变化的，a可以对应B，也可以对应C，还能对应D，此处不要混淆

move(n - 1, a, b, c) # 将上面的n -1个盘子从A移动到 C
move(1, a, c, b) #将最后一个盘子移动到B  ，b,c 参数位置有变化
move(n-1, b, a, c) # 将B上面的n-1个盘子移动到C，大功告成
想要问题快速得到解答？分享给朋友试试：



ParetoFront
#2 Created at 1天前
  写的挺明白的，本来不太懂， 看你这个懂了，不过最后部分写错了吧，应该是

move(n - 1, a, c, b)  # 将A最上面的n -1个盘子移动到B
move(1, a, b, c)  #将A上最后一个盘子移动到C
move(n-1, b, a, c)  # 将B上面的n-1个盘子移动到C
'''
